# 面试-mysql

## MySQL数据库的常用存储引擎以及它们的区别？
MyISAM：不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，支持全文索引。

InnoDB：支持事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢，5.6之后支持全文索引。

存储引擎是基于表的，而不是数据库

## 说说对SQL语句优化有哪些方法？
（1）Where子句中：where表之间的连接必须写在其他Where条件之前（这是他妈的谣言！mysql底层有查询优化器会自动处理这种情况）

（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。

（3）避免在索引列上使用计算

（4）避免在索引列上使用IS NULL和IS NOT NULL 和 !=

（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

（6）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描

## 主键、外键和索引的区别？
主键、外键和索引的区别

定义：

主键–唯一标识一条记录，不能有重复的，不允许为空

外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值

索引–该字段没有重复值，但可以有一个空值

作用：

主键–用来保证数据完整性

外键–用来和其他表建立联系用的

索引–是提高查询排序的速度

个数：

主键–主键只能有一个

外键–一个表可以有多个外键

索引–一个表可以有多个唯一索引

## 什么是事务？及其特性？
事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。

特性：

（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态

（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

简单理解：在事务里的操作，要么全部成功，要么全部失败。


## 常用字符继
- ASC0II字符集 共128个字符
- ISO 8859-1 共256个字符
- GB2312
- GBK
- utf8

## MySQL中utf8mb3和utf8mb4的区别
utf8mb3 阉割版utf8，使用1-3个字节
utf8mb4 正宗的utf8，使用1-4个字符，如果有emoji表情的话建议使用mb4

## 关于InnerDb的一些知识点
1. InnoDB中页的大小一般为 16 KB。
2. InnoDB行格式有4个，分别为 Compact（紧凑型）、Redundant（预防型）、Dynamic（灵活型）和Compressed（压缩型）
3. 如果没有where的话 count在innerDb中需要全表扫描

## 变长字段的四种行格式不同之处
1. COMPACT ：变长字段长度列表，null值列表，记录信息头   |  列1 列2 列3
2. Redundant：字段长度偏移列表，记录信息头             | 列1 列2 列3
3. Dynamic和Compressed：与COMPACT相同，但处理行溢出时有分歧，COMPACT会在真实数据（列1，列2，列3）记录前768字节的数据和一个偏移指针，剩下的字节存储到其他页中，但Dynamic和Compressed只会记录一个指针，并把全部字节记录到其他页中。其中Compressed会对这些字节进行压缩处理。

## innerDb中有多少种索引
1. 聚簇索引 = 主键
2. 二级索引 = 建立的其他索引
3. 联合索引
4. 二级索引和联合索引中记录了聚簇索引的id，这是为了回表操作

##  mysql 段，区，页的概念
1. 一个页16k
2. 物理上连续的64个页为一个区
3. 每一个索引都会有2个段，一个叶子节点段，一个非叶子节点段。

## innerDb中的b+树
1. 聚簇索引的叶子节点中存放的是完整数据，目录节点存放的是索引。
2. 二级索引和联合索引的叶子节点存放的是聚簇索引的id

## InnerDb的几个知识点
1. InnerDb的底层是b+树，最下面的一层是叶子节点（用户数据存储的位置），其他的都是节点（索引是记在这里的），多个节点存储在一张页目录中
2. InnerDb会为每个索引都建立一颗b+树，因此索引有着时间和空间上的代价。
3. 联合索引存在最左原则
4. where中查找的索引顺序如何写都无所谓，因为有查询优化器，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件
5. 索引列的类型尽可能要小，比如能用int就不要用bitInt，原因是数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。
6. 尽可能要做顺序插入，否则会产生页分裂 如 主键123567  然后插了个4 就会产生页分裂
## Where什么情况会导致索引失效
1. 联合索引中的范围查询之后的条件会失效，入主键（A），二级索引（B） 当where A > 10 && A < 100 && B > 10 只能用到A索引，B会失效，但是如果是 A = 10 && B > 20 是可以用到A和B索引的
2. 使用通配符 %xxx%的时候
3. 联合查询中未遵守最左原则
4. 使用NOT NULL 和 NOT IN 的时候
5. 使用了表达式计算
6. 类型不一致比如字段是int 但是搜索的时候用了字符串 反之亦然
## OrderBy什么时候会导致索引失效
1. 当orderBy ASC、DESC混用 的时候 会导致联合索引失效
2. 排序列包含非同一个索引的列，如建立了A，B，C 但是orderBy了一个A，D 这样也会导致失效

## MyIsam的表结构

1. Myisam 所有的索引都是二级索引
2. myisam 会为每一张表建立3个文件 分别为 xxx.frm（结构） xxx.MYD（数据文件） xxx.MYI（索引文件）

## 视图
1. mysql会为视图创建一个 视图名.frm 的文件

## 事务
1. 事务拥有原子性，隔离性，一致性和持久性
2. 支持事务的引擎为InderDb和NDB
3. 系统变量中又有一个autocommit，即为自动提交，当他打开的时候，没有显式的用begin开启事务 则认为每一条sql都为一个事务。

## redoLog
1. 重做日志，会记录操作，如将第0号表空间的100号页面的偏移量为1000处的值更新为2。原因是为了在修改的时候不需要每次都刷到磁盘，又能保证持久性。
2. redoLog页为512kb
3. 默认的redoLog的缓冲区为16M

## redelog什么时候刷盘
1. 缓冲区如果写到大约一半的时候就会进行刷盘
2. 后台线程每秒都会刷一次
3. 当刷脏页的时候会刷redeLog
4. 正常关闭服务器的时候
5. 做checkpoint的时候
6. 当innodb_flush_log_at_trx_commit 设置为1的时候 （0为不刷，2为刷到操作系统的缓冲区，此时操作系统挂了数据会丢失）

## undo日志
1. 回滚日志
2. 事务打开后如果全是查询没有修改的话不会记录，每个日志都会产生一个事务ID
3. 每对一条记录做改变，就会产生一条
4. purge线程线程会真正删除

## 脏读写，不可重复读和幻读的概念
1. 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写
2. 如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读
3. 如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读
4. 如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读

##  四种隔离级别
1. READ UNCOMMITTED：未提交读。 可能发生 脏读、不可重复读和幻读 原理是读最新版的记录

2. READ COMMITTED：已提交读。 可能发生不可重复读和幻读问题  原理是每次读会创建一个ReadView

3. REPEATABLE READ：可重复读。 可能发生幻读问题 原理是在第一次读取数据时生成一个ReadView

4. SERIALIZABLE：可串行化。 都不可能

## 怎么解决脏读、不可重复读、幻读这些问题呢？
方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。 需要隔离级别 可重复度，主要是解决了幻读
方案二：读、写操作都采用加锁的方式。

## mysql的锁
1. SELECT ... LOCK IN SHARE MODE; 共享锁
2. SELECT ... FOR UPDATE; 排他锁

## 一些被误导的点
拥有IS NULL、IS NOT NULL、!=这三个条件的查询是在什么情况下使用二级索引来执行的，核心结论就是：成本决定执行计划，跟使用什么查询条件并没有什么关系。优化器会首先针对可能使用到的二级索引划分几个扫描区间，然后分别调查这些区间内有多少条记录，在这些扫描区间内的二级索引记录的总和占总共的记录数量的比例达到某个值时，优化器将放弃使用二级索引执行查询，转而采用全表扫描。

## mysql的更新执行过程
1. 优化器判断是否走索引
2. 将记录所在的页面加载到buffer pool
3. 检测更新前后记录是否一样
4. 调用存储引擎接口进行更新
5. 更新聚簇索引记录
6. 记录undo日志
7. 修改页面内容
8. 记录redo日志
9. 更新二级索引记录
10. 记录binlog

## binLog的作用
会记录表所有更改操作,包括更新删除数据,更改表结构等等,主要用于人工恢复数据

## mysql主从原理
原理是通过二进制文件binlog日志，mysql启动的时候master检测到有slave后开启一个dump线程，slave开启一个I/O Thread线程和master的dump线程进行tcp连接，第一次的时候是slave主动去让master发送的获取一份完整数据，
而后master会通过dump主动推给slave，slave在拿到数据后会将其存入relaylog，也就是中继日志。再由自身的sql thread线程去读取，读取的时候是开启多个worker去处理的



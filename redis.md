# 面试-redis
## Redis是什么
Redis是一个key-value存储系统
## Redis支持的数据类型有哪些
1. string：最基本的数据类型，二进制安全的字符串，最大512M。
2. list：按照添加顺序保持顺序的字符串列表。
3. set：无序的字符串集合，不存在重复的元素。
4. sorted set：已排序的字符串集合。
5. hash：key-value对的一种集合。
6. bitmap：更细化的一种操作，以bit为单位。
7. hyperloglog：基于概率的数据结构。 # 2.8.9新增
8. Geo:地理位置信息储存起来， 并对这些信息进行操作   # 3.2新增
9. 流（Stream）# 5.0新增

## Redis应用场景
1. 缓存数据
2. 分布式session
3. 分布式锁
4. INCR计数器
5. 文章的阅读量，微博点赞数，允许一定的延迟，先写入 Redis 再定时同步到数据库
6. 全局ID,INCRBY，利用原子性
7. INCR 限流
   以访问者的 IP 和其他信息作为 key，访问一
   增加一次计数，超过次数则返回 false。
8. setbit 位操作


## 几个简单小知识点
1. string 最大长度为512M
2. list底层是链表
2. 分布式锁可以用setNx，但不能解决超时问题


## redis如何解决缓存雪崩、缓存击穿和缓存穿透问题
### 缓存雪崩

原因1：大量数据同时过期

处理方式：

第一种：设置过期时间的时候加上随机数

第二种：进行服务降级，当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；
当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。

原因2：redis宕机

处理方式：

在业务系统中实现服务熔断或请求限流机制。

### 缓存击穿

原因：访问非常频繁的热点数据过期

处理方式：

对于访问特别频繁的热点数据，我们就不设置过期时间

### 缓存穿透

缓存和数据库中没有要访问的数据

处理方式：

1. 缓存空值或缺省值。
2. 使用布隆过滤器快速判断数据是否存在
3. 对入口进行合法性判断

## redis的删除
redis删除 = 定时删除 + 惰性删除 + 淘汰策略
### 定时删除
在Redis缓存的数据中，几乎所有数据都会被标上一个过期时间，而这个过期时间是作为Redis清理数据腾出空间的一个重要依据。
定时删除的原理在于：为数据设置一个过期时间。每过一个时间周期，Redis会随机遍历一部分数据，当检测到数据已经到达了过期时间后，Redis就会将这些数据清除掉。 （为什么是随机遍历：如果全部遍历，十分耗费时间，影响性能）

### 惰性删除
惰性删除的原理在于：当有请求访问到了一个已到达过期时间且未被清理的数据时，Redis就会检测到这个过期数据并进行清除。

### 淘汰策略


#### 关于redis的淘汰策略LRU（最近最少使用淘汰算法，LRU关键是看数据最后一次被使用到发生替换的时间长短，时间越长，数据就会被置换；）
1. noeviction 只允许读不允许写
2. volatile-lru  淘汰过期的key lru算法
3. volatile-ttl  淘汰过期的key key的剩余时间小于tll
4. volatile-random 随机淘汰过期的
5. allkeys-lru 所有key lru
6. allkeys-random 所有key 随机

#### 关于redis的淘汰策略LFU（最不经常使用淘汰算法，LFU关键是看一定时间段内页面被使用的频率（次数），使用频率越低，数据就会被置换。）
1. volatile-lfu 过期 lfu
2. allkeys-lfu 全部 lfu


## Redis 持久化

提供了多种不同级别的持久化方式:一种是RDB,另一种是AOF.

RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。

### []()[]()RDB 的优点:

**RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集**。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

### []()[]()RDB 的缺点:

如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， **因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作**。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； **如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失**。

### []()[]()AOF 的优点:

使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。**AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）** 。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。  
Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

### []()[]()AOF 的缺点:

**对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积**。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而**关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此**。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。

### []()[]()RDB 和 AOF ,我应该用哪一个？

一般来说,**如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能**。如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。因为以上提到的种种原因， 未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）

### []()[]()RDB 快照:

在默认情况下， **Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作**。比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：  
save 60 1000  
这种持久化方式被称为快照（snapshot）。



